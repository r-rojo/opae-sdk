.\" Man page generated from reStructuredText.
.
.TH "FPGA_CXX_API" "8" "Dec 09, 2020" "2.0.1" "OPAE"
.SH NAME
fpga_cxx_api \- OPAE C++ API
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
The reference documentation for the OPAE C++ Core API is grouped into the following
sections:
.INDENT 0.0
.IP \(bu 2
\fI\%Overview\fP
.IP \(bu 2
\fI\%Goals\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Simplicity\fP
.IP \(bu 2
\fI\%Extensibility and Interoperability\fP
.IP \(bu 2
\fI\%Modern C++ Coding Practices\fP
.IP \(bu 2
\fI\%Error Handling\fP
.IP \(bu 2
\fI\%Coding Style\fP
.UNINDENT
.IP \(bu 2
\fI\%Fundamental Types\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Properties\fP
.IP \(bu 2
\fI\%pvalue.h\fP
.IP \(bu 2
\fI\%properties.h\fP
.IP \(bu 2
\fI\%Resource Classes\fP
.IP \(bu 2
\fI\%token.h\fP
.IP \(bu 2
\fI\%handle.h\fP
.IP \(bu 2
\fI\%shared_buffer.h\fP
.IP \(bu 2
\fI\%errors.h\fP
.IP \(bu 2
\fI\%events.h\fP
.IP \(bu 2
\fI\%sysobject.h\fP
.IP \(bu 2
\fI\%Exceptions\fP
.IP \(bu 2
\fI\%except.h\fP
.IP \(bu 2
\fI\%Misc\fP
.IP \(bu 2
\fI\%version.h\fP
.UNINDENT
.UNINDENT
.SH OVERVIEW
.sp
The OPAE C++ API enables C++ developers with the means to use FPGA resources
by integrating the OPAE software stack into C++ applications.
.SH GOALS
.SS Simplicity
.sp
Keep the API as small and lightweight as possible. Although features such as
system validation and orchestration are beyond the scope of this API, using
this API for their development should be relatively easy.
.SS Extensibility and Interoperability
.sp
While keeping to the goal of simplicity, the OPAE C++ API is designed to allow
for better reuse by either extending the API or by integrating with other
languages.
.SS Modern C++ Coding Practices
.sp
The OPAE C++ API uses the C++ 11 standard library and makes use of its features
whenever practical. The OPAE C++ API is also designed to require the minimum
number of third\-party libraries/dependencies.
.SS Error Handling
.sp
The OPAE C++ API is designed to throw exceptions when appropriate. The
structure of OPAE C++ exceptions is similar to the error codes in the
OPAE C API. This gives users of the API more freedom on error handling
while providing better debug information in cases of failure.
.SS Coding Style
.sp
For formatting of the OPAE C++ API complies with most of the recommendations
of the Google C++ style. For example, the OPAE C++ API uses:
.INDENT 0.0
.IP \(bu 2
opening braces on the same line as their scope definition
.IP \(bu 2
spaces instead of tabs for indentation
.IP \(bu 2
indentation of two spaces
.UNINDENT
.SH FUNDAMENTAL TYPES
.sp
Basic types for the OPAE C++ API are found in the \fIopae::fpga::types\fP
namespace. They serve as an adapter layer between the OPAE C API and
the OPAE C++ layer. Aside from providing a C++ binding to the C
fundamental types, these types also:
.INDENT 0.0
.IP \(bu 2
manage the lifetime and scope of the corresponding C struct.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
For example a C++ destructor will take care of calling the
appropriate C function to release the data structure being
wrapped.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
provide a friendly syntax for using the OPAE C type.
.UNINDENT
.sp
Most classes in this namespace have a \fIc_type()\fP method that returns
the C data structure being wrapped, making it easy to use the OPAE C++
type with the OPAE C API. Alternatively, most classes in this namespace
have implicit conversion operators that enable interoperability with
the OPAE C API.
.SS Properties
.sp
C++ class \fIproperties\fP wraps \fIfpga_properties\fP and uses \fIpvalue\fP
and \fIguid_t\fP to get and set properties stored in an instance of
an \fIfpga_properties\fP\&. \fIpvalue\fP and \fIguid_t\fP are designed to call
an accessor method in the OPAE C API to either read property
values or write them. Most accessor methods in the OPAE C API
share a similar signature, so \fIpvalue\fP generalizes them into
common operations that translate into calling the corresponding
C API function. \fIguid_t\fP follows similar patterns when reading
or assigning values.
.SS pvalue.h
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B struct guid_t 
\fI#include <opae/cxx/core/pvalue.h>\fP
.sp
Representation of the guid member of a properties object. 
.sp
Public Functions
.INDENT 7.0
.TP
.B guid_t(fpga_properties *\fIp\fP) 
Construct the \fI\%guid_t\fP given its containing fpga_properties. 
.UNINDENT
.INDENT 7.0
.TP
.B void update() 
Update the local cached copy of the guid. 
.UNINDENT
.INDENT 7.0
.TP
.B operator uint8_t*() 
Return a raw pointer to the guid. .INDENT 7.0
.TP
\fBReturn Value\fP
.INDENT 7.0
.IP \(bu 2
\fBnullptr\fP: if the guid could not be queried. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B const uint8_t *c_type() const 
Return a raw pointer to the guid. 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%guid_t\fP &operator=(fpga_guid \fIg\fP) 
Assign from fpga_guid Sets the guid field of the associated properties object using the OPAE properties API. .INDENT 7.0
.TP
\fBReturn\fP
a reference to this \fI\%guid_t\fP\&. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] g\fP: The given fpga_guid. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool operator==(const fpga_guid &\fIg\fP) 
Compare contents with an fpga_guid. .INDENT 7.0
.TP
\fBReturn Value\fP
.INDENT 7.0
.IP \(bu 2
\fBThe\fP: result of memcmp of the two objects. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void parse(const char *\fIstr\fP) 
Convert a string representation of a guid to binary. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] str\fP: The guid string. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool is_set() const 
Tracks whether the cached local copy of the guid is valid. 
.UNINDENT
.INDENT 7.0
.TP
.B void invalidate() 
Invalidate the cached local copy of the guid. 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B fpga_properties *props_ 
.UNINDENT
.INDENT 7.0
.TP
.B bool is_set_ 
.UNINDENT
.INDENT 7.0
.TP
.B std::array<uint8_t, 16> data_ 
.UNINDENT
.sp
Friends
.INDENT 7.0
.TP
.B friend std::ostream &operator<<(std::ostream &\fIostr\fP, const \fI\%guid_t\fP &\fIg\fP) 
Send the string representation of the \fI\%guid_t\fP to the given stream. 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B template<typename T> struct pvalue 
\fI#include <opae/cxx/core/pvalue.h>\fP
.sp
Wraps OPAE properties defined in the OPAE C API by associating an \fBfpga_properties\fP reference with the getters and setters defined for a property. 
.sp
.INDENT 7.0
.TP
\fBTemplate Parameters\fP
.INDENT 7.0
.IP \(bu 2
\fBT\fP: The type of the property value being wrapped 
.UNINDENT
.UNINDENT

.sp
Public Types
.INDENT 7.0
.TP
.B typedef std::conditional<std::is_same<\fI\%T\fP, char*>::value, fpga_result (*)(fpga_properties, \fI\%T\fP), fpga_result (*)(fpga_properties, \fI\%T\fP*)>::type getter_t 
Define getter function as getter_t For \fBchar*\fP types, do not use T* as the second argument but instead use T. 
.UNINDENT
.INDENT 7.0
.TP
.B typedef fpga_result (*setter_t)(fpga_properties, \fI\%T\fP) 
Define the setter function as setter_t. 
.UNINDENT
.INDENT 7.0
.TP
.B typedef std::conditional<std::is_same<\fI\%T\fP, char*>::value, typename std::string, \fI\%T\fP>::type copy_t 
Define the type of our copy variable For \fBchar*\fP types use std::string as the copy. 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B pvalue() 
.UNINDENT
.INDENT 7.0
.TP
.B pvalue(fpga_properties *\fIp\fP, \fI\%getter_t\fP \fIg\fP, \fI\%setter_t\fP \fIs\fP) 
pvalue contructor that takes in a reference to fpga_properties and corresponding accessor methods for a property 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBp\fP: A reference to an fpga_properties 
.IP \(bu 2
\fBg\fP: The getter function 
.IP \(bu 2
\fBs\fP: The setter function 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<\fI\%T\fP> &operator=(const \fI\%T\fP &\fIv\fP) 
Overload of \fB=\fP operator that calls the wrapped setter. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A reference to itself 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBv\fP: The value to set
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool operator==(const \fI\%T\fP &\fIother\fP) 
Compare a property for equality with a value. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
Whether or not the property is equal to the value 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBother\fP: The value being compared to
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void update() 
.UNINDENT
.INDENT 7.0
.TP
.B operator copy_t() 
Implicit converter operator \- calls the wrapped getter. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The property value after calling the getter or a default value of the value type 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B fpga_result get_value(\fI\%T\fP &\fIvalue\fP) const 
.UNINDENT
.INDENT 7.0
.TP
.B bool is_set() const 
Tracks whether the cached local copy of the pvalue is valid. 
.UNINDENT
.INDENT 7.0
.TP
.B void invalidate() 
Invalidate the cached local copy of the pvalue. 
.UNINDENT
.INDENT 7.0
.TP
.B void update() 
Template specialization of \fBchar*\fP type property updater. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The result of the property getter function. 
.UNINDENT

.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B fpga_properties *props_ 
.UNINDENT
.INDENT 7.0
.TP
.B bool is_set_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%getter_t\fP get_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%setter_t\fP set_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%copy_t\fP copy_ 
.UNINDENT
.sp
Friends
.INDENT 7.0
.TP
.B friend std::ostream &operator<<(std::ostream &\fIostr\fP, const \fI\%pvalue\fP<\fI\%T\fP> &\fIp\fP) 
Stream overalod operator. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The stream operator after streaming the property value 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBostr\fP: The output stream 
.IP \(bu 2
\fBp\fP: A reference to a pvalue<T> object
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS properties.h
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B class properties 
\fI#include <opae/cxx/core/properties.h>\fP
.sp
Wraps an OPAE fpga_properties object.
.sp
properties are information describing an accelerator resource that is identified by its token. The properties are used during enumeration to narrow the search for an accelerator resource, and after enumeration to provide the configuration of that resource. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef std::shared_ptr<\fI\%properties\fP> ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B properties(const \fI\%properties\fP &\fIp\fP) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%properties\fP &operator=(const \fI\%properties\fP &\fIp\fP) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B ~properties() 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_properties c_type() const 
Get the underlying fpga_properties object. 
.UNINDENT
.INDENT 7.0
.TP
.B operator fpga_properties() const 
Get the underlying fpga_properties object. 
.UNINDENT
.sp
Public Members
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<fpga_objtype> type 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint32_t> num_errors 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint16_t> segment 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint8_t> bus 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint8_t> device 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint8_t> function 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint8_t> socket_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint32_t> num_slots 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint64_t> bbs_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<fpga_version> bbs_version 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint16_t> vendor_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint16_t> device_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<char*> model 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint64_t> local_memory_size 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint64_t> capabilities 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint32_t> num_mmio 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint32_t> num_interrupts 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<fpga_accelerator_state> accelerator_state 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<uint64_t> object_id 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%pvalue\fP<fpga_token> parent 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%guid_t\fP guid 
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B \fI\%properties\fP::\fI\%ptr_t\fP get() 
Create a new properties object. .INDENT 7.0
.TP
\fBReturn\fP
A properties smart pointer. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%properties\fP::\fI\%ptr_t\fP get(fpga_guid \fIguid_in\fP) 
Create a new properties object from a guid. .INDENT 7.0
.TP
\fBReturn\fP
A properties smart pointer with its guid initialized to guid_in 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBguid_in\fP: A guid to set in the properties 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%properties\fP::\fI\%ptr_t\fP get(fpga_objtype \fIobjtype\fP) 
Create a new properties object from an fpga_objtype. .INDENT 7.0
.TP
\fBReturn\fP
A properties smart pointer with its object type set to objtype. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBobjtype\fP: An object type to set in the properties 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%properties\fP::\fI\%ptr_t\fP get(std::shared_ptr<\fI\%token\fP> \fIt\fP) 
Retrieve the properties for a given token object. .INDENT 7.0
.TP
\fBReturn\fP
A properties smart pointer for the given token. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] t\fP: A token identifying the accelerator resource. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%properties\fP::\fI\%ptr_t\fP get(fpga_token \fIt\fP) 
Retrieve the properties for a given fpga_token. .INDENT 7.0
.TP
\fBReturn\fP
A properties smart pointer for the given fpga_token. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] t\fP: An fpga_token identifying the accelerator resource. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%properties\fP::\fI\%ptr_t\fP get(std::shared_ptr<\fI\%handle\fP> \fIh\fP) 
Retrieve the properties for a given handle object. .INDENT 7.0
.TP
\fBReturn\fP
A properties smart pointer for the given handle. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] h\fP: A handle identifying the accelerator resource. 
.UNINDENT
.UNINDENT

.UNINDENT
.sp
Public Static Attributes
.INDENT 7.0
.TP
.B static const std::vector<\fI\%properties\fP::\fI\%ptr_t\fP> none 
An empty vector of properties. Useful for enumerating based on a "match all" criteria. 
.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B properties(bool \fIalloc_props\fP = true) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B fpga_properties props_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Resource Classes
.sp
The \fItoken\fP, \fIhandle\fP, and \fIshared_buffer\fP classes are used to
enumerate and access FPGA resources. \fIproperties\fP are used to
narrow the search space for \fItoken\fP\(aqs. Before enumerating the
accelerator resources in the system, applications can produce
one or more \fIproperties\fP objects whose values are set to the
desired characteristics for the resource. For example, an
application may search for an accelerator resource based on
its guid.
.sp
Once one or more \fItoken\fP\(aqs have been enumerated, the application
must choose which \fItoken\fP\(aqs to request. The \fItoken\fP is then
converted to a \fIhandle\fP by requesting that a \fIhandle\fP object
be allocated and opened for it.
.sp
Once a \fIhandle\fP has been successfully opened, the application
can read and write the associated configuration and status
space. Additionally, the application may use the \fIhandle\fP to
allocate \fIshared_buffer\fP\(aqs or to register \fIevent\fP\(aqs. The
\fIshared_buffer\fP and \fIevent\fP objects retain a reference to
their owning \fIhandle\fP so that the \fIhandle\fP does not lose
scope before freeing the \fIshared_buffer\fP and \fIevent\fP objects.
.SS token.h
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B class token 
\fI#include <opae/cxx/core/token.h>\fP
.sp
Wraps the OPAE fpga_token primitive. token\(aqs are created from an enumeration operation that uses properties describing an accelerator resource as search criteria. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef std::shared_ptr<\fI\%token\fP> ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B ~token() 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_token c_type() const 
Retrieve the underlying fpga_token primitive. 
.UNINDENT
.INDENT 7.0
.TP
.B operator fpga_token() const 
Retrieve the underlying fpga_token primitive. 
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B std::vector<\fI\%token\fP::\fI\%ptr_t\fP> enumerate(const std::vector<\fI\%properties\fP::\fI\%ptr_t\fP> &\fIprops\fP) 
Obtain a vector of token smart pointers for given search criteria. .INDENT 7.0
.TP
\fBReturn\fP
A set of known tokens that match the search. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] props\fP: The search criteria. 
.UNINDENT
.UNINDENT

.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B token(fpga_token \fItok\fP) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B fpga_token token_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS handle.h
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B class handle 
\fI#include <opae/cxx/core/handle.h>\fP
.sp
An allocated accelerator resource
.sp
Represents an accelerator resource that has been allocated by OPAE. Depending on the type of resource, its register space may be read/written using a handle object. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef std::shared_ptr<\fI\%handle\fP> ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B handle(const \fI\%handle\fP&) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%handle\fP &operator=(const \fI\%handle\fP&) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B ~handle() 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_handle c_type() const 
Retrieve the underlying OPAE handle. 
.UNINDENT
.INDENT 7.0
.TP
.B operator fpga_handle() const 
Retrieve the underlying OPAE handle. 
.UNINDENT
.INDENT 7.0
.TP
.B void reconfigure(uint32_t \fIslot\fP, const uint8_t *\fIbitstream\fP, size_t \fIsize\fP, int \fIflags\fP) 
Load a bitstream into an FPGA slot. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBslot\fP: The slot number to program 
.IP \(bu 2
\fBbitstream\fP: The bitstream binary data 
.IP \(bu 2
\fBsize\fP: The size of the bitstream 
.IP \(bu 2
\fBflags\fP: Flags that control behavior of reconfiguration. Value of 0 indicates no flags. FPGA_RECONF_FORCE indicates that the bitstream is programmed into the slot without checking if the resource is currently in use.
.UNINDENT
.TP
\fBExceptions\fP
.INDENT 7.0
.IP \(bu 2
\fB\fI\%invalid_param\fP\fP: if the handle is not an FPGA device handle or if the other parameters are not valid. 
.IP \(bu 2
\fBexception\fP: if an internal error is encountered. 
.IP \(bu 2
\fBbusy\fP: if the accelerator for the given slot is in use. 
.IP \(bu 2
\fB\fI\%reconf_error\fP\fP: if errors are reported by the driver (CRC or protocol errors). 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B uint32_t read_csr32(uint64_t \fIoffset\fP, uint32_t \fIcsr_space\fP = 0) const 
Read 32 bits from a CSR belonging to a resource associated with a handle. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The 32\-bit value read from the CSR 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] offset\fP: The register offset 
.IP \(bu 2
\fB[in] csr_space\fP: The CSR space to read from. Default is 0.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void write_csr32(uint64_t \fIoffset\fP, uint32_t \fIvalue\fP, uint32_t \fIcsr_space\fP = 0) 
Write 32 bit to a CSR belonging to a resource associated with a handle. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] offset\fP: The register offset. 
.IP \(bu 2
\fB[in] value\fP: The 32\-bit value to write to the register. 
.IP \(bu 2
\fB[in] csr_space\fP: The CSR space to read from. Default is 0. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B uint64_t read_csr64(uint64_t \fIoffset\fP, uint32_t \fIcsr_space\fP = 0) const 
Read 64 bits from a CSR belonging to a resource associated with a handle. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The 64\-bit value read from the CSR 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] offset\fP: The register offset 
.IP \(bu 2
\fB[in] csr_space\fP: The CSR space to read from. Default is 0.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void write_csr64(uint64_t \fIoffset\fP, uint64_t \fIvalue\fP, uint32_t \fIcsr_space\fP = 0) 
Write 64 bits to a CSR belonging to a resource associated with a handle. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] offset\fP: The register offset. 
.IP \(bu 2
\fB[in] value\fP: The 64\-bit value to write to the register. 
.IP \(bu 2
\fB[in] csr_space\fP: The CSR space to read from. Default is 0. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void write_csr512(uint64_t \fIoffset\fP, const void *\fIvalue\fP, uint32_t \fIcsr_space\fP = 0) 
Write 512 bits to a CSR belonging to a resource associated with a handle. 
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] offset\fP: The register offset. 
.IP \(bu 2
\fB[in] value\fP: Pointer to the 512\-bit value to write to the register. 
.IP \(bu 2
\fB[in] csr_space\fP: The CSR space to read from. Default is 0. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B uint8_t *mmio_ptr(uint64_t \fIoffset\fP, uint32_t \fIcsr_space\fP = 0) const 
Retrieve a pointer to the MMIO region. .INDENT 7.0
.TP
\fBReturn\fP
MMIO base + offset 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] offset\fP: The byte offset to add to MMIO base. 
.IP \(bu 2
\fB[in] csr_space\fP: The desired CSR space. Default is 0. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void reset() 
Reset the accelerator identified by this handle 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_result close() 
Close an accelerator resource (if opened)
.sp
.INDENT 7.0
.TP
\fBReturn\fP
fpga_result indication the result of closing the handle or FPGA_EXCEPTION if handle is not opened
.TP
\fBNote\fP
This is available for explicitly closing a handle. The destructor for handle will call close. 
.UNINDENT

.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B \fI\%handle\fP::\fI\%ptr_t\fP open(fpga_token \fItoken\fP, int \fIflags\fP) 
Open an accelerator resource, given a raw fpga_token
.sp
.INDENT 7.0
.TP
\fBReturn\fP
pointer to the mmio base + offset for the given csr space 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] token\fP: A token describing the accelerator resource to be allocated.
.IP \(bu 2
\fB[in] flags\fP: The flags parameter to fpgaOpen()\&.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%handle\fP::\fI\%ptr_t\fP open(\fI\%token\fP::ptr_t \fItoken\fP, int \fIflags\fP) 
Open an accelerator resource, given a token object
.sp
.INDENT 7.0
.TP
\fBReturn\fP
shared ptr to a handle object 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] token\fP: A token object describing the accelerator resource to be allocated.
.IP \(bu 2
\fB[in] flags\fP: The flags parameter to fpgaOpen()\&.
.UNINDENT
.UNINDENT

.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B handle(fpga_handle \fIh\fP) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B fpga_handle handle_ 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_token token_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS shared_buffer.h
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B class shared_buffer 
\fI#include <opae/cxx/core/shared_buffer.h>\fP
.sp
Host/AFU shared memory blocks
.sp
\fI\%shared_buffer\fP abstracts a memory block that may be shared between the host cpu and an accelerator. The block may be allocated by the \fI\%shared_buffer\fP class itself (see allocate), or it may be allocated elsewhere and then attached to a \fI\%shared_buffer\fP object via attach. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef std::size_t size_t 
.UNINDENT
.INDENT 7.0
.TP
.B typedef std::shared_ptr<\fI\%shared_buffer\fP> ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B shared_buffer(const \fI\%shared_buffer\fP&) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%shared_buffer\fP &operator=(const \fI\%shared_buffer\fP&) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B ~shared_buffer() 
\fI\%shared_buffer\fP destructor. 
.UNINDENT
.INDENT 7.0
.TP
.B void release() 
Disassociate the \fI\%shared_buffer\fP object from the resource used to create it. If the buffer was allocated using the allocate function then the buffer is freed. 
.UNINDENT
.INDENT 7.0
.TP
.B uint8_t *c_type() const 
Retrieve the virtual address of the buffer base.
.sp
.INDENT 7.0
.TP
\fBNote\fP
Instances of a shared buffer can only be created using either \(aqallocate\(aq or \(aqattach\(aq static factory function. Because these functions return a shared pointer (std::shared_ptr) to the instance, references to an instance are counted automatically by design of the shared_ptr class. Calling \(aq\fI\%c_type()\fP\(aq function is provided to get access to the raw data but isn\(aqt used in tracking its reference count. Assigning this to a variable should be done in limited scopes as this variable can be defined in an outer scope and may outlive the \fI\%shared_buffer\fP object. Once the reference count in the shared_ptr reaches zero, the \fI\%shared_buffer\fP object will be released and deallocated, turning any variables assigned from a call to \(aq\fI\%c_type()\fP\(aq into dangling pointers. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%handle\fP::\fI\%ptr_t\fP owner() const 
Retrieve the handle smart pointer associated with this buffer. 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%size_t\fP size() const 
Retrieve the length of the buffer in bytes. 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t wsid() const 
Retrieve the underlying buffer\(aqs workspace id. 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t io_address() const 
Retrieve the address of the buffer suitable for programming into the accelerator device. 
.UNINDENT
.INDENT 7.0
.TP
.B void fill(int \fIc\fP) 
Write c to each byte location in the buffer. 
.UNINDENT
.INDENT 7.0
.TP
.B int compare(\fI\%ptr_t\fP \fIother\fP, \fI\%size_t\fP \fIlen\fP) const 
Compare this \fI\%shared_buffer\fP (the first len bytes) to that held in other, using memcmp(). 
.UNINDENT
.INDENT 7.0
.TP
.B template<typename T> \fI\%T\fP read(\fI\%size_t\fP \fIoffset\fP) const 
Read a T\-sized block of memory at the given location. .INDENT 7.0
.TP
\fBReturn\fP
A T from buffer base + offset. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] offset\fP: The byte offset from the start of the buffer. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B template<typename T> void write(const \fI\%T\fP &\fIvalue\fP, \fI\%size_t\fP \fIoffset\fP) 
Write a T\-sized block of memory to the given location. .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] value\fP: The value to write. 
.IP \(bu 2
\fB[in] offset\fP: The byte offset from the start of the buffer. 
.UNINDENT
.UNINDENT

.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B \fI\%shared_buffer\fP::\fI\%ptr_t\fP allocate(\fI\%handle\fP::ptr_t \fIhandle\fP, \fI\%size_t\fP \fIlen\fP, bool \fIread_only\fP = false) 
\fI\%shared_buffer\fP factory method \- allocate a \fI\%shared_buffer\fP\&. .INDENT 7.0
.TP
\fBReturn\fP
A valid \fI\%shared_buffer\fP smart pointer on success, or an empty smart pointer on failure. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] handle\fP: The handle used to allocate the buffer. 
.IP \(bu 2
\fB[in] len\fP: The length in bytes of the requested buffer. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%shared_buffer\fP::\fI\%ptr_t\fP attach(\fI\%handle\fP::ptr_t \fIhandle\fP, uint8_t *\fIbase\fP, \fI\%size_t\fP \fIlen\fP, bool \fIread_only\fP = false) 
Attach a pre\-allocated buffer to a \fI\%shared_buffer\fP object.
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A valid \fI\%shared_buffer\fP smart pointer on success, or an empty smart pointer on failure. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] handle\fP: The handle used to attach the buffer. 
.IP \(bu 2
\fB[in] base\fP: The base of the pre\-allocated memory. 
.IP \(bu 2
\fB[in] len\fP: The size of the pre\-allocated memory, which must be a multiple of the page size. 
.UNINDENT
.UNINDENT

.UNINDENT
.sp
Protected Functions
.INDENT 7.0
.TP
.B shared_buffer(\fI\%handle\fP::ptr_t \fIhandle\fP, \fI\%size_t\fP \fIlen\fP, uint8_t *\fIvirt\fP, uint64_t \fIwsid\fP, uint64_t \fIio_address\fP) 
.UNINDENT
.sp
Protected Attributes
.INDENT 7.0
.TP
.B \fI\%handle\fP::\fI\%ptr_t\fP handle_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%size_t\fP len_ 
.UNINDENT
.INDENT 7.0
.TP
.B uint8_t *virt_ 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t wsid_ 
.UNINDENT
.INDENT 7.0
.TP
.B uint64_t io_address_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS errors.h
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B class error 
\fI#include <opae/cxx/core/errors.h>\fP
.sp
An error object represents an error register for a resource. This is used to read out the raw value in the register. No parsing is done by this class. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef std::shared_ptr<\fI\%error\fP> ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B error(const \fI\%error\fP &\fIe\fP) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%error\fP &operator=(const \fI\%error\fP &\fIe\fP) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B std::string name() 
Get the error register name. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A std::string object set to the error name. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B bool can_clear() 
Indicates whether an error register can be cleared. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A boolean value indicating if the error register can be cleared. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B uint64_t read_value() 
Read the raw value contained in the associated error register. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A 64\-bit value (unparsed) read from the error register 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B ~error() 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_error_info c_type() const 
Get the C data structure. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The fpga_error_info that contains the name and the can_clear boolean. 
.UNINDENT

.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B \fI\%error\fP::\fI\%ptr_t\fP get(\fI\%token\fP::\fI\%ptr_t\fP \fItok\fP, uint32_t \fInum\fP) 
Factory function for creating an error object. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A shared_ptr containing the error object 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBtok\fP: The token object representing a resource. 
.IP \(bu 2
\fBnum\fP: The index of the error register. This must be lower than the num_errors property of the resource.
.UNINDENT
.UNINDENT

.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B error(\fI\%token\fP::ptr_t \fItoken\fP, uint32_t \fInum\fP) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%token\fP::\fI\%ptr_t\fP token_ 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_error_info error_info_ 
.UNINDENT
.INDENT 7.0
.TP
.B uint32_t error_num_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS events.h
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B class event 
\fI#include <opae/cxx/core/events.h>\fP
.sp
Wraps fpga event routines in OPAE C. 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef std::shared_ptr<\fI\%event\fP> ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B ~event() 
Destroy event and associated resources. 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_event_handle get() 
Get the fpga_event_handle contained in this object. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The fpga_event_handle contained in this object 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B operator fpga_event_handle() 
Coversion operator for converting to fpga_event_handle objects. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The fpga_event_handle contained in this object 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B int os_object() const 
Get OS Object from the event object. 
.sp
Get an OS specific object from the event which can be used to subscribe for events. On Linux, the object corresponds to a file descriptor that can be used with select/poll/epoll calls.
.sp
.INDENT 7.0
.TP
\fBReturn\fP
An integer object representing the OS object 
.UNINDENT

.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B \fI\%event\fP::\fI\%ptr_t\fP register_event(\fI\%handle\fP::\fI\%ptr_t\fP \fIh\fP, \fI\%event\fP::\fI\%type_t\fP \fIt\fP, int \fIflags\fP = 0) 
Factory function to create event objects. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A shared ptr to an event object 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fBh\fP: A shared ptr of a resource handle 
.IP \(bu 2
\fBt\fP: The resource type 
.IP \(bu 2
\fBflags\fP: Event registration flags passed on to fpgaRegisterEvent
.UNINDENT
.UNINDENT

.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B event(\fI\%handle\fP::\fI\%ptr_t\fP \fIh\fP, \fI\%event\fP::type_t \fIt\fP, fpga_event_handle \fIevent_h\fP) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B \fI\%handle\fP::\fI\%ptr_t\fP handle_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%event\fP::\fI\%type_t\fP type_ 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_event_handle event_handle_ 
.UNINDENT
.INDENT 7.0
.TP
.B int os_object_ 
.UNINDENT
.INDENT 7.0
.TP
.B struct type_t 
\fI#include <opae/cxx/core/events.h>\fP
.sp
C++ struct that is interchangeable with fpga_event_type enum. 
.sp
Public Functions
.INDENT 7.0
.TP
.B type_t(fpga_event_type \fIc_type\fP) 
.UNINDENT
.INDENT 7.0
.TP
.B operator fpga_event_type() 
.UNINDENT
.sp
Public Static Attributes
.INDENT 7.0
.TP
.B constexpr fpga_event_type interrupt = FPGA_EVENT_INTERRUPT 
.UNINDENT
.INDENT 7.0
.TP
.B constexpr fpga_event_type error = FPGA_EVENT_ERROR 
.UNINDENT
.INDENT 7.0
.TP
.B constexpr fpga_event_type power_thermal = FPGA_EVENT_POWER_THERMAL 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B fpga_event_type type_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS sysobject.h
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B class sysobject 
\fI#include <opae/cxx/core/sysobject.h>\fP
.sp
Wraps the OPAE fpga_object primitive. sysobject\(aqs are created from a call to fpgaTokenGetObject, fpgaHandleGetObject, or fpgaObjectGetObject 
.sp
Public Types
.INDENT 7.0
.TP
.B typedef std::shared_ptr<\fI\%sysobject\fP> ptr_t 
.UNINDENT
.sp
Public Functions
.INDENT 7.0
.TP
.B sysobject() = delete 
.UNINDENT
.INDENT 7.0
.TP
.B sysobject(const \fI\%sysobject\fP &\fIo\fP) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%sysobject\fP &operator=(const \fI\%sysobject\fP &\fIo\fP) = delete 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%sysobject\fP::\fI\%ptr_t\fP get(const std::string &\fIname\fP, int \fIflags\fP = 0) 
Get a sysobject from an object. This will be read\-write if its parent was created from a handle.. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A shared_ptr to a sysobject instance. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] name\fP: An identifier representing an object belonging to this object. 
.IP \(bu 2
\fB[in] flags\fP: Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects. Flags are defaulted to 0 meaning no flags.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%sysobject\fP::\fI\%ptr_t\fP get(int \fIindex\fP) 
Get a sysobject from a container object. This will be read\-write if its parent was created from a handle.. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A shared_ptr to a sysobject instance. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] index\fP: An index number to get.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B ~sysobject() 
.UNINDENT
.INDENT 7.0
.TP
.B uint32_t size() const 
Get the size (in bytes) of the object. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The number of bytes that the object occupies in memory. 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B uint64_t read64(int \fIflags\fP = 0) const 
Read a 64\-bit value from an FPGA object. The value is assumed to be in string format and will be parsed. See flags below for changing that behavior. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A 64\-bit value from the object. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] flags\fP: Flags that control how the object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data. If FPGA_OBJECT_RAW is used, then the data will be read as raw bytes into the uint64_t pointer variable. Flags are defaulted to 0 meaning no flags.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B void write64(uint64_t \fIvalue\fP, int \fIflags\fP = 0) const 
Write 64\-bit value to an FPGA object. The value will be converted to string before writing. See flags below for changing that behavior. 
.sp
.INDENT 7.0
.TP
\fBNote\fP
This operation will force a sync operation to update its cached buffer 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] value\fP: The value to write to the object. 
.IP \(bu 2
\fB[in] flags\fP: Flags that control how the object is written If FPGA_OBJECT_RAW is used, then the value will be written as raw bytes. Flags are defaulted to 0 meaning no flags.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B std::vector<uint8_t> bytes(int \fIflags\fP = 0) const 
Get all raw bytes from the object. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A vector of all bytes in the object. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] flags\fP: Flags that control how object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B std::vector<uint8_t> bytes(uint32_t \fIoffset\fP, uint32_t \fIsize\fP, int \fIflags\fP = 0) const 
Get a subset of raw bytes from the object. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A vector of size bytes in the object starting at offset. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] offset\fP: The bytes offset for the start of the returned vector. 
.IP \(bu 2
\fB[in] size\fP: The number of bytes for the returned vector. 
.IP \(bu 2
\fB[in] flags\fP: Flags that control how object is read If FPGA_OBJECT_SYNC is used then object will update its buffered copy before retrieving the data.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B enum fpga_sysobject_type type() const 
Get the object type (attribute or container) 
.UNINDENT
.INDENT 7.0
.TP
.B fpga_object c_type() const 
Retrieve the underlying fpga_object primitive. 
.UNINDENT
.INDENT 7.0
.TP
.B operator fpga_object() const 
Retrieve the underlying fpga_object primitive. 
.UNINDENT
.sp
Public Static Functions
.INDENT 7.0
.TP
.B \fI\%sysobject\fP::\fI\%ptr_t\fP get(\fI\%token\fP::\fI\%ptr_t\fP \fIt\fP, const std::string &\fIname\fP, int \fIflags\fP = 0) 
Get a sysobject from a token. This will be read\-only. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A shared_ptr to a sysobject instance. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] t\fP: Token object representing a resource. 
.IP \(bu 2
\fB[in] name\fP: An identifier representing an object belonging to a resource represented by the token. 
.IP \(bu 2
\fB[in] flags\fP: Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B \fI\%sysobject\fP::\fI\%ptr_t\fP get(\fI\%handle\fP::\fI\%ptr_t\fP \fIh\fP, const std::string &\fIname\fP, int \fIflags\fP = 0) 
Get a sysobject from a handle. This will be read\-write. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
A shared_ptr to a sysobject instance. 
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] h\fP: Handle object representing an open resource. 
.IP \(bu 2
\fB[in] name\fP: An identifier representing an object belonging to a resource represented by the handle. 
.IP \(bu 2
\fB[in] flags\fP: Control behavior of object identification and creation. FPGA_OBJECT_GLOB is used to indicate that the name should be treated as a globbing expression. FPGA_OBJECT_RECURSE_ONE indicates that subobjects be created for objects one level down from the object identified by name. FPGA_OBJECT_RECURSE_ALL indicates that subobjects be created for all objects below the current object identified by name.
.UNINDENT
.UNINDENT

.UNINDENT
.sp
Private Functions
.INDENT 7.0
.TP
.B sysobject(fpga_object \fIsysobj\fP, \fI\%token\fP::ptr_t \fItoken\fP, \fI\%handle\fP::\fI\%ptr_t\fP \fIhnd\fP) 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B fpga_object sysobject_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%token\fP::\fI\%ptr_t\fP token_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%handle\fP::\fI\%ptr_t\fP handle_ 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Exceptions
.sp
When the OPAE C++ API encounters an error from the OPAE C
API, it captures the current source code location and
the error code into an object of type \fIexcept\fP, then
throws the \fIexcept\fP\&. Applications should implement the
appropriate catch blocks required to respond to runtime
exceptions.
.SS except.h
.sp
Defines
.INDENT 0.0
.TP
.B OPAECXX_HERE 
Construct a src_location object for the current source line. 
.UNINDENT
.INDENT 0.0
.TP
.B ASSERT_FPGA_OK(\fIr\fP) 
Macro to check of result is FPGA_OK If not, throw exception that corresponds to the result code. 
.UNINDENT
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B class busy : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
busy exception
.sp
busy tracks the source line of origin for exceptions thrown when the error code FPGA_BUSY is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B busy(\fI\%src_location\fP \fIloc\fP) noexcept 
busy constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class except : public std::exception 
\fI#include <opae/cxx/core/except.h>\fP
.sp
Generic OPAE exception
.sp
An except tracks the source line of origin and an optional fpga_result. If no fpga_result is given, then FPGA_EXCEPTION is used. 
.sp
Subclassed by \fI\%opae::fpga::types::busy\fP, \fI\%opae::fpga::types::exception\fP, \fI\%opae::fpga::types::invalid_param\fP, \fI\%opae::fpga::types::no_access\fP, \fI\%opae::fpga::types::no_daemon\fP, \fI\%opae::fpga::types::no_driver\fP, \fI\%opae::fpga::types::no_memory\fP, \fI\%opae::fpga::types::not_found\fP, \fI\%opae::fpga::types::not_supported\fP, \fI\%opae::fpga::types::reconf_error\fP
.sp
Public Functions
.INDENT 7.0
.TP
.B except(\fI\%src_location\fP \fIloc\fP) noexcept 
except constructor The fpga_result value is FPGA_EXCEPTION.
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B except(fpga_result \fIres\fP, \fI\%src_location\fP \fIloc\fP) noexcept 
except constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] res\fP: The fpga_result value associated with this exception. 
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B except(fpga_result \fIres\fP, const char *\fImsg\fP, \fI\%src_location\fP \fIloc\fP) noexcept 
except constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] res\fP: The fpga_result value associated with this exception. 
.IP \(bu 2
\fB[in] msg\fP: The error message as a string 
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B const char *what() const noexcept override 
Convert this except to an informative string. 
.UNINDENT
.INDENT 7.0
.TP
.B operator fpga_result() const noexcept 
Convert this except to its fpga_result. 
.UNINDENT
.sp
Public Static Attributes
.INDENT 7.0
.TP
.B const std::size_t MAX_EXCEPT = 256 
.UNINDENT
.sp
Protected Attributes
.INDENT 7.0
.TP
.B fpga_result res_ 
.UNINDENT
.INDENT 7.0
.TP
.B const char *msg_ 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%src_location\fP loc_ 
.UNINDENT
.INDENT 7.0
.TP
.B char buf_[MAX_EXCEPT] 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class exception : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
exception exception
.sp
exception tracks the source line of origin for exceptions thrown when the error code FPGA_EXCEPTION is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B exception(\fI\%src_location\fP \fIloc\fP) noexcept 
exception constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class invalid_param : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%invalid_param\fP exception
.sp
\fI\%invalid_param\fP tracks the source line of origin for exceptions thrown when the error code FPGA_INVALID_PARAM is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B invalid_param(\fI\%src_location\fP \fIloc\fP) noexcept 
\fI\%invalid_param\fP constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class no_access : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%no_access\fP exception
.sp
\fI\%no_access\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NO_ACCESS is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B no_access(\fI\%src_location\fP \fIloc\fP) noexcept 
\fI\%no_access\fP constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class no_daemon : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%no_daemon\fP exception
.sp
\fI\%no_daemon\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NO_DAEMON is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B no_daemon(\fI\%src_location\fP \fIloc\fP) noexcept 
\fI\%no_daemon\fP constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class no_driver : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%no_driver\fP exception
.sp
\fI\%no_driver\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NO_DRIVER is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B no_driver(\fI\%src_location\fP \fIloc\fP) noexcept 
\fI\%no_driver\fP constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class no_memory : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%no_memory\fP exception
.sp
\fI\%no_memory\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NO_MEMORY is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B no_memory(\fI\%src_location\fP \fIloc\fP) noexcept 
\fI\%no_memory\fP constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class not_found : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%not_found\fP exception
.sp
\fI\%not_found\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NOT_FOUND is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B not_found(\fI\%src_location\fP \fIloc\fP) noexcept 
\fI\%not_found\fP constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class not_supported : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%not_supported\fP exception
.sp
\fI\%not_supported\fP tracks the source line of origin for exceptions thrown when the error code FPGA_NOT_SUPPORTED is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B not_supported(\fI\%src_location\fP \fIloc\fP) noexcept 
\fI\%not_supported\fP constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class reconf_error : public \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%except\fP 
\fI#include <opae/cxx/core/except.h>\fP
.sp
\fI\%reconf_error\fP exception
.sp
\fI\%reconf_error\fP tracks the source line of origin for exceptions thrown when the error code FPGA_RECONF_ERROR is returned from a call to an OPAE C API function 
.sp
Public Functions
.INDENT 7.0
.TP
.B reconf_error(\fI\%src_location\fP \fIloc\fP) noexcept 
\fI\%reconf_error\fP constructor
.sp
.INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] loc\fP: Location where the exception was constructed. 
.UNINDENT
.UNINDENT

.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B class src_location 
\fI#include <opae/cxx/core/except.h>\fP
.sp
Identify a particular line in a source file. 
.sp
Public Functions
.INDENT 7.0
.TP
.B src_location(const char *\fIfile\fP, const char *\fIfn\fP, int \fIline\fP) noexcept 
\fI\%src_location\fP constructor .INDENT 7.0
.TP
\fBParameters\fP
.INDENT 7.0
.IP \(bu 2
\fB[in] file\fP: The source file name, typically \fBFILE\fP\&. 
.IP \(bu 2
\fB[in] fn\fP: The current function, typically \fBfunc\fP\&. 
.IP \(bu 2
\fB[in] line\fP: The current line number, typically \fBLINE\fP\&. 
.UNINDENT
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B src_location(const \fI\%src_location\fP &\fIother\fP) noexcept 
.UNINDENT
.INDENT 7.0
.TP
.B \fI\%src_location\fP &operator=(const \fI\%src_location\fP &\fIother\fP) noexcept 
.UNINDENT
.INDENT 7.0
.TP
.B const char *file() const noexcept 
Retrieve the file name component of the location. 
.UNINDENT
.INDENT 7.0
.TP
.B const char *fn() const noexcept 
Retrieve the function name component of the location. 
.UNINDENT
.INDENT 7.0
.TP
.B int line() const noexcept 
Retrieve the line number component of the location. 
.UNINDENT
.sp
Private Members
.INDENT 7.0
.TP
.B const char *file_ 
.UNINDENT
.INDENT 7.0
.TP
.B const char *fn_ 
.UNINDENT
.INDENT 7.0
.TP
.B int line_ 
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B namespace detail 
.sp
Typedefs
.INDENT 7.0
.TP
.B typedef bool (*exception_fn)(fpga_result, const \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%src_location\fP &loc) 
typedef function pointer that returns bool if result is FPGA_OK 
.UNINDENT
.sp
Functions
.INDENT 7.0
.TP
.B template<typename T> constexpr bool is_ok(fpga_result \fIresult\fP, const \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%src_location\fP &\fIloc\fP) 
is_ok is a template function that throws an excpetion of its template argument type if the result code is not FPGA_OK. Otherwise it returns true. 
.UNINDENT
.INDENT 7.0
.TP
.B void assert_fpga_ok(fpga_result \fIresult\fP, const \fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%src_location\fP &\fIloc\fP) 
.UNINDENT
.sp
Variables
.INDENT 7.0
.TP
.B \fI\%exception_fn\fP opae_exceptions[12] = {\fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%invalid_param\fP>, \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%busy\fP>, \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%exception\fP>, \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%not_found\fP>, \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%no_memory\fP>, \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%not_supported\fP>, \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%no_driver\fP>, \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%no_daemon\fP>, \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%no_access\fP>, \fI\%is_ok\fP<\fI\%opae\fP::\fI\%fpga\fP::\fI\%types\fP::\fI\%reconf_error\fP>} 
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Misc
.sp
The \fIversion\fP class wraps the OPAE C version API.
.SS version.h
.INDENT 0.0
.TP
.B namespace opae 
.INDENT 7.0
.TP
.B namespace fpga 
.INDENT 7.0
.TP
.B namespace types 
.INDENT 7.0
.TP
.B class version 
\fI#include <opae/cxx/core/version.h>\fP
.sp
Public Static Functions
.INDENT 7.0
.TP
.B fpga_version as_struct() 
Get the package version information as a struct. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The package version as an \fBfpga_version\fP struct 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B std::string as_string() 
Get the package version information as a string. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The package version as an \fBstd::string\fP object 
.UNINDENT

.UNINDENT
.INDENT 7.0
.TP
.B std::string build() 
Get the package build information as a string. 
.sp
.INDENT 7.0
.TP
\fBReturn\fP
The package build as an \fBstd::string\fP object 
.UNINDENT

.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SH AUTHOR
Intel DCG FPT SW
.SH COPYRIGHT
2017 Intel Corporation
.\" Generated by docutils manpage writer.
.
