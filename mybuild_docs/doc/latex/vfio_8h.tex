\doxysection{opae-\/libs/include/opae/vfio.h File Reference}
\label{vfio_8h}\index{opae-\/libs/include/opae/vfio.h@{opae-\/libs/include/opae/vfio.h}}


A\+P\+Is to manage a P\+C\+Ie device via vfio-\/pci.  


{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$stdint.\+h$>$}\newline
{\ttfamily \#include $<$pthread.\+h$>$}\newline
{\ttfamily \#include $<$linux/vfio.\+h$>$}\newline
\doxysubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__iova__range}{opae\+\_\+vfio\+\_\+iova\+\_\+range}}
\item 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__group}{opae\+\_\+vfio\+\_\+group}}
\item 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__sparse__info}{opae\+\_\+vfio\+\_\+sparse\+\_\+info}}
\item 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__device__region}{opae\+\_\+vfio\+\_\+device\+\_\+region}}
\item 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__device}{opae\+\_\+vfio\+\_\+device}}
\item 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__buffer}{opae\+\_\+vfio\+\_\+buffer}}
\item 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{vfio_8h_a3d3ccbf4a24acbe8f3fc4d973ab46b1a}{opae\+\_\+vfio\+\_\+open}} (struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$v, const char $\ast$pciaddr)
\item 
int \mbox{\hyperlink{vfio_8h_a8d6d1f473a26bc0fbe83e6894b8fb607}{opae\+\_\+vfio\+\_\+secure\+\_\+open}} (struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$v, const char $\ast$pciaddr, const char $\ast$token)
\item 
int \mbox{\hyperlink{vfio_8h_afc30450c9b7ebc22709557cac5ab9181}{opae\+\_\+vfio\+\_\+region\+\_\+get}} (struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$v, uint32\+\_\+t index, uint8\+\_\+t $\ast$$\ast$ptr, size\+\_\+t $\ast$size)
\item 
int \mbox{\hyperlink{vfio_8h_a63c468f18994a45604b372c31a1e26cf}{opae\+\_\+vfio\+\_\+buffer\+\_\+allocate}} (struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$v, size\+\_\+t $\ast$size, uint8\+\_\+t $\ast$$\ast$buf, uint64\+\_\+t $\ast$iova)
\item 
int \mbox{\hyperlink{vfio_8h_ae2a60d829698d793ab9a4ad351d2596d}{opae\+\_\+vfio\+\_\+buffer\+\_\+free}} (struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$v, uint8\+\_\+t $\ast$buf)
\item 
void \mbox{\hyperlink{vfio_8h_a70fd22e64704c8f0090adb810d51fa83}{opae\+\_\+vfio\+\_\+close}} (struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$v)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A\+P\+Is to manage a P\+C\+Ie device via vfio-\/pci. 

Presents a simple interface for interacting with a P\+C\+Ie device that is bound to the vfio-\/pci driver. See \href{https://kernel.org/doc/Documentation/vfio.txt}{\texttt{ https\+://kernel.\+org/doc/\+Documentation/vfio.\+txt}} for a description of vfio-\/pci.

Provides A\+P\+Is for opening/closing the device, querying info about the M\+M\+IO regions of the device, and allocating/mapping and freeing/unmapping D\+MA buffers. 

\doxysubsection{Data Structure Documentation}
\index{opae\_vfio\_iova\_range@{opae\_vfio\_iova\_range}}\label{structopae__vfio__iova__range}
\doxysubsubsection{struct opae\+\_\+vfio\+\_\+iova\+\_\+range}
IO Virtual Address Range

A range of allocatable I\+O\+VA offsets. Used for mapping D\+MA buffers. 

Definition at line 55 of file vfio.\+h.

\begin{DoxyFields}{Data Fields}
\mbox{\label{vfio_8h_ae44d6d78fc59fec1829117f80f09d676}} 
uint64\_t&
start&
Start of this range of offsets. \\
\hline

\mbox{\label{vfio_8h_a8e09837d655b7187d704d1dec69bd3e2}} 
uint64\_t&
end&
End of this range of offsets. \\
\hline

\mbox{\label{vfio_8h_a9aa30cca772595b7e9d404df2615351b}} 
uint64\_t&
next\_ptr&
The next allocatable offset. \\
\hline

\mbox{\label{vfio_8h_acdadb8bd4497fd424a045de13f1c0570}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__iova__range}{opae\_vfio\_iova\_range}} $\ast$&
next&
Pointer to next in list. \\
\hline

\end{DoxyFields}
\index{opae\_vfio\_group@{opae\_vfio\_group}}\label{structopae__vfio__group}
\doxysubsubsection{struct opae\+\_\+vfio\+\_\+group}
V\+F\+IO group

Each device managed by vfio-\/pci belongs to a V\+F\+IO group rooted at /dev/vfio/N, where N is the group number. 

Definition at line 68 of file vfio.\+h.

\begin{DoxyFields}{Data Fields}
\mbox{\label{vfio_8h_aa7f7d7923d85bdb630b0b1ec49be5f92}} 
char $\ast$&
group\_device&
Full path to the group device. \\
\hline

\mbox{\label{vfio_8h_a51d7ad18b5d27f7713877bc9e7f31c92}} 
int&
group\_fd&
File descriptor for the group device. \\
\hline

\end{DoxyFields}
\index{opae\_vfio\_sparse\_info@{opae\_vfio\_sparse\_info}}\label{structopae__vfio__sparse__info}
\doxysubsubsection{struct opae\+\_\+vfio\+\_\+sparse\+\_\+info}
M\+M\+IO sparse-\/mappable region info

Describes a range of sparse-\/mappable M\+M\+IO, for M\+M\+IO ranges that have non-\/contiguous addresses. 

Definition at line 79 of file vfio.\+h.

\begin{DoxyFields}{Data Fields}
\mbox{\label{vfio_8h_a0f2a85a947a552ace76e299bd66dc91d}} 
uint32\_t&
index&
Region index, from 0. \\
\hline

\mbox{\label{vfio_8h_afc2d2ce14bb3aeaba49efa5e8a063dfb}} 
uint32\_t&
offset&
Offset of sparse region. \\
\hline

\mbox{\label{vfio_8h_adefec9a427d225b75b9b272710174df8}} 
uint32\_t&
size&
Size of sparse region. \\
\hline

\mbox{\label{vfio_8h_a68ad8ff776b8b47536d8f515eadffaa4}} 
uint8\_t $\ast$&
ptr&
Virtual address of sparse region. \\
\hline

\mbox{\label{vfio_8h_a6557e0f64b5cb7f9e89218aaa535d583}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__sparse__info}{opae\_vfio\_sparse\_info}} $\ast$&
next&
Pointer to next in list. \\
\hline

\end{DoxyFields}
\index{opae\_vfio\_device\_region@{opae\_vfio\_device\_region}}\label{structopae__vfio__device__region}
\doxysubsubsection{struct opae\+\_\+vfio\+\_\+device\+\_\+region}
M\+M\+IO region info

Describes a range of mappable M\+M\+IO. 

Definition at line 92 of file vfio.\+h.

\begin{DoxyFields}{Data Fields}
\mbox{\label{vfio_8h_a276412974a0b0ffb91ac3200149761b0}} 
uint32\_t&
region\_index&
Region index, from 0. \\
\hline

\mbox{\label{vfio_8h_a37bbecd990a16e1d985bece6d8395e86}} 
uint8\_t $\ast$&
region\_ptr&
Virtual address of region. \\
\hline

\mbox{\label{vfio_8h_add69a93ef216ab2ed1a053f506605f8e}} 
size\_t&
region\_size&
Size of region. \\
\hline

\mbox{\label{vfio_8h_a52a91a9da49e5a61dbb5e8f511733aba}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__sparse__info}{opae\_vfio\_sparse\_info}} $\ast$&
region\_sparse&
For sparse regions. \\
\hline

\mbox{\label{vfio_8h_ad58eb4a337da7515de0acca200a2463c}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__device__region}{opae\_vfio\_device\_region}} $\ast$&
next&
Pointer to next in list. \\
\hline

\end{DoxyFields}
\index{opae\_vfio\_device@{opae\_vfio\_device}}\label{structopae__vfio__device}
\doxysubsubsection{struct opae\+\_\+vfio\+\_\+device}
V\+F\+IO device

Each V\+F\+IO device has a file descriptor that is used to query information about the device M\+M\+IO regions and config space. 

Definition at line 106 of file vfio.\+h.

\begin{DoxyFields}{Data Fields}
\mbox{\label{vfio_8h_a5567cac847af54d1b68cd11de6d9071a}} 
int&
device\_fd&
Device file descriptor. \\
\hline

\mbox{\label{vfio_8h_a484988f748aa324957a2046bc2590e10}} 
uint64\_t&
device\_config\_offset&
Offset of P\+C\+Ie config space. \\
\hline

\mbox{\label{vfio_8h_ad9ca3ae45cd69d3eec04297820c98db4}} 
uint32\_t&
device\_num\_regions&
Total M\+M\+IO region count. \\
\hline

\mbox{\label{vfio_8h_ab45bac066081e611b23ff38c90ab6f26}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__device__region}{opae\_vfio\_device\_region}} $\ast$&
regions&
Region list pointer. \\
\hline

\end{DoxyFields}
\index{opae\_vfio\_buffer@{opae\_vfio\_buffer}}\label{structopae__vfio__buffer}
\doxysubsubsection{struct opae\+\_\+vfio\+\_\+buffer}
System D\+MA buffer

Describes a system memory address space that is capable of D\+MA. 

Definition at line 118 of file vfio.\+h.

\begin{DoxyFields}{Data Fields}
\mbox{\label{vfio_8h_a10c301384270143e76d93675740d2a05}} 
uint8\_t $\ast$&
buffer\_ptr&
Buffer virtual address. \\
\hline

\mbox{\label{vfio_8h_a52535a9a9d8c7a129fb313d14a96dc47}} 
size\_t&
buffer\_size&
Buffer size. \\
\hline

\mbox{\label{vfio_8h_a4bccc7115924108b58c421955a6b9775}} 
uint64\_t&
buffer\_iova&
Buffer I\+O\+VA address. \\
\hline

\mbox{\label{vfio_8h_a4a373bbf6acc2d47dd674a6ea44771e8}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__buffer}{opae\_vfio\_buffer}} $\ast$&
next&
Pointer to next in list. \\
\hline

\end{DoxyFields}
\index{opae\_vfio@{opae\_vfio}}\label{structopae__vfio}
\doxysubsubsection{struct opae\+\_\+vfio}
O\+P\+AE V\+F\+IO device abstraction

This structure is used to interact with the O\+P\+AE V\+F\+IO A\+PI. It tracks data related to the V\+F\+IO container, group, and device. A mutex is provided for thread safety. 

Definition at line 132 of file vfio.\+h.

\begin{DoxyFields}{Data Fields}
\mbox{\label{vfio_8h_ad9ef4790801de907acfa18409dedfaab}} 
pthread\_mutex\_t&
lock&
For thread safety. \\
\hline

\mbox{\label{vfio_8h_a7ca65a6a199f57795216b4af7e152b7e}} 
char $\ast$&
cont\_device&
\char`\"{}/dev/vfio/vfio\char`\"{} \\
\hline

\mbox{\label{vfio_8h_a12cbdd053863723e3b51564dab3b1de5}} 
char $\ast$&
cont\_pciaddr&
P\+C\+Ie address, eg 0000\+:00\+:00.\+0 \\
\hline

\mbox{\label{vfio_8h_a7cdb7430f296c4c469dc54f075014245}} 
int&
cont\_fd&
Container file descriptor. \\
\hline

\mbox{\label{vfio_8h_a65cb87d5caf739177f1627f369704ea4}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__iova__range}{opae\_vfio\_iova\_range}} $\ast$&
cont\_ranges&
List of I\+O\+VA ranges. \\
\hline

\mbox{\label{vfio_8h_a5aa9019a215689bb45c6de05425489e0}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__group}{opae\_vfio\_group}}&
group&
The V\+F\+IO device group. \\
\hline

\mbox{\label{vfio_8h_a0321bdb1c77dad0ad3f57d32d5f00de6}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__device}{opae\_vfio\_device}}&
device&
The V\+F\+IO device. \\
\hline

\mbox{\label{vfio_8h_a339f29d4740af95c4c033966188ce52e}} 
struct \mbox{\hyperlink{vfio_8h_structopae__vfio__buffer}{opae\_vfio\_buffer}} $\ast$&
cont\_buffers&
List of allocated D\+MA buffers. \\
\hline

\end{DoxyFields}


\doxysubsection{Function Documentation}
\mbox{\label{vfio_8h_a3d3ccbf4a24acbe8f3fc4d973ab46b1a}} 
\index{vfio.h@{vfio.h}!opae\_vfio\_open@{opae\_vfio\_open}}
\index{opae\_vfio\_open@{opae\_vfio\_open}!vfio.h@{vfio.h}}
\doxysubsubsection{\texorpdfstring{opae\_vfio\_open()}{opae\_vfio\_open()}}
{\footnotesize\ttfamily int opae\+\_\+vfio\+\_\+open (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$}]{v,  }\item[{const char $\ast$}]{pciaddr }\end{DoxyParamCaption})}

Open and populate a V\+F\+IO device

Opens the P\+C\+Ie device corresponding to the address given in pciaddr. The device must be bound to the vfio-\/pci driver prior to opening it. The data structures corresponding to I\+O\+VA space, M\+M\+IO regions, and D\+MA buffers are initialized.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em v} & Storage for the device info. May be stack-\/resident. \\
\hline
\mbox{\texttt{ in}}  & {\em pciaddr} & The P\+C\+Ie address of the requested device. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Non-\/zero on error. Zero on success.
\end{DoxyReturn}
Example 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ sudo opaevfio -\/i 0000:00:00.0 -\/u user -\/g group}
\end{DoxyCode}


Example 
\begin{DoxyCode}{0}
\DoxyCodeLine{opae\_vfio v;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (opae\_vfio\_open(\&v, \textcolor{stringliteral}{"0000:00:00.0"})) \{}
\DoxyCodeLine{  \textcolor{comment}{// handle error}}
\DoxyCodeLine{\}}
\end{DoxyCode}
 \mbox{\label{vfio_8h_a8d6d1f473a26bc0fbe83e6894b8fb607}} 
\index{vfio.h@{vfio.h}!opae\_vfio\_secure\_open@{opae\_vfio\_secure\_open}}
\index{opae\_vfio\_secure\_open@{opae\_vfio\_secure\_open}!vfio.h@{vfio.h}}
\doxysubsubsection{\texorpdfstring{opae\_vfio\_secure\_open()}{opae\_vfio\_secure\_open()}}
{\footnotesize\ttfamily int opae\+\_\+vfio\+\_\+secure\+\_\+open (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$}]{v,  }\item[{const char $\ast$}]{pciaddr,  }\item[{const char $\ast$}]{token }\end{DoxyParamCaption})}

Open and populate a V\+F\+IO device

Opens the P\+C\+Ie device corresponding to the address given in pciaddr, using the VF token (G\+U\+ID) given in token. The device must be bound to the vfio-\/pci driver prior to opening it. The data structures corresponding to I\+O\+VA space, M\+M\+IO regions, and D\+MA buffers are initialized.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em v} & Storage for the device info. May be stack-\/resident. \\
\hline
\mbox{\texttt{ in}}  & {\em pciaddr} & The P\+C\+Ie address of the requested device. \\
\hline
\mbox{\texttt{ in}}  & {\em token} & The G\+U\+ID representing the VF token. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Non-\/zero on error. Zero on success.
\end{DoxyReturn}
Example 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ sudo opaevfio -\/i 0000:00:00.0 -\/u user -\/g group}
\end{DoxyCode}


Example 
\begin{DoxyCode}{0}
\DoxyCodeLine{opae\_vfio v;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (opae\_vfio\_secure\_open(\&v, \textcolor{stringliteral}{"0000:00:00.0"},}
\DoxyCodeLine{                          \textcolor{stringliteral}{"00f5ad6b-\/2edd-\/422e-\/9d1e-\/34124c686fec"})) \{}
\DoxyCodeLine{  \textcolor{comment}{// handle error}}
\DoxyCodeLine{\}}
\end{DoxyCode}
 \mbox{\label{vfio_8h_afc30450c9b7ebc22709557cac5ab9181}} 
\index{vfio.h@{vfio.h}!opae\_vfio\_region\_get@{opae\_vfio\_region\_get}}
\index{opae\_vfio\_region\_get@{opae\_vfio\_region\_get}!vfio.h@{vfio.h}}
\doxysubsubsection{\texorpdfstring{opae\_vfio\_region\_get()}{opae\_vfio\_region\_get()}}
{\footnotesize\ttfamily int opae\+\_\+vfio\+\_\+region\+\_\+get (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$}]{v,  }\item[{uint32\+\_\+t}]{index,  }\item[{uint8\+\_\+t $\ast$$\ast$}]{ptr,  }\item[{size\+\_\+t $\ast$}]{size }\end{DoxyParamCaption})}

Query device M\+M\+IO region

Retrieves info describing the M\+M\+IO region with the given region index. The device structure v must have been previously opened by a call to opae\+\_\+vfio\+\_\+open.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em v} & The open O\+P\+AE V\+F\+IO device. \\
\hline
\mbox{\texttt{ in}}  & {\em index} & The zero-\/based index of the desired M\+M\+IO region. \\
\hline
\mbox{\texttt{ out}}  & {\em ptr} & Optional pointer to receive the virtual address for the region. Pass N\+U\+LL to ignore. \\
\hline
\mbox{\texttt{ out}}  & {\em size} & Optional pointer to receive the size of the M\+M\+IO region. Pass N\+U\+LL to ignore. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Non-\/zero on error (including index out-\/of-\/range). Zero on success.
\end{DoxyReturn}
Example 
\begin{DoxyCode}{0}
\DoxyCodeLine{opae\_vfio v;}
\DoxyCodeLine{}
\DoxyCodeLine{uint8\_t *fme\_virt = NULL;}
\DoxyCodeLine{uint8\_t *port\_virt = NULL;}
\DoxyCodeLine{\textcolor{keywordtype}{size\_t} fme\_size = 0;}
\DoxyCodeLine{\textcolor{keywordtype}{size\_t} port\_size = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (opae\_vfio\_open(\&v, \textcolor{stringliteral}{"0000:00:00.0"})) \{}
\DoxyCodeLine{  \textcolor{comment}{// handle error}}
\DoxyCodeLine{\} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{  opae\_vfio\_region\_get(\&v, 0, \&fme\_virt, \&fme\_size);}
\DoxyCodeLine{  opae\_vfio\_region\_get(\&v, 2, \&port\_virt, \&port\_size);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 \mbox{\label{vfio_8h_a63c468f18994a45604b372c31a1e26cf}} 
\index{vfio.h@{vfio.h}!opae\_vfio\_buffer\_allocate@{opae\_vfio\_buffer\_allocate}}
\index{opae\_vfio\_buffer\_allocate@{opae\_vfio\_buffer\_allocate}!vfio.h@{vfio.h}}
\doxysubsubsection{\texorpdfstring{opae\_vfio\_buffer\_allocate()}{opae\_vfio\_buffer\_allocate()}}
{\footnotesize\ttfamily int opae\+\_\+vfio\+\_\+buffer\+\_\+allocate (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$}]{v,  }\item[{size\+\_\+t $\ast$}]{size,  }\item[{uint8\+\_\+t $\ast$$\ast$}]{buf,  }\item[{uint64\+\_\+t $\ast$}]{iova }\end{DoxyParamCaption})}

Allocate and map system buffer

Allocate, map, and retrieve info for a system buffer capable of D\+MA. Saves an entry in the v-\/$>$cont\+\_\+buffers list. If the buffer is not explicitly freed by opae\+\_\+vfio\+\_\+buffer\+\_\+free, it will be freed during opae\+\_\+vfio\+\_\+close.

mmap is used for the allocation. If the size is greater than 2MB, then the allocation request is fulfilled by a 1GB huge page. Else, if the size is greater than 4096, then the request is fulfilled by a 2MB huge page. Else, the request is fulfilled by the non-\/huge page pool.

\begin{DoxyNote}{Note}
Allocations from the huge page pool require that huge pages be configured on the system. Huge pages may be configured on the kernel boot command prompt. Example default\+\_\+hugepagesz=1G hugepagesz=1G hugepages=2 hugepagesz=2M hugepages=8

Huge pages may also be configured at runtime. Example sudo sh -\/c \textquotesingle{}echo 8 $>$ /sys/kernel/mm/hugepages/hugepages-\/2048k\+B/nr\+\_\+hugepages\textquotesingle{} sudo sh -\/c \textquotesingle{}echo 2 $>$ /sys/kernel/mm/hugepages/hugepages-\/1048576k\+B/nr\+\_\+hugepages\textquotesingle{}

Be sure that the I\+O\+M\+MU is also enabled using the follow kernel boot command\+: intel\+\_\+iommu=on
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em v} & The open O\+P\+AE V\+F\+IO device. \\
\hline
\mbox{\texttt{ in,out}}  & {\em size} & A pointer to the requested size. The size may be rounded to the next page size prior to return from the function. \\
\hline
\mbox{\texttt{ out}}  & {\em buf} & Optional pointer to receive the virtual address for the buffer. Pass N\+U\+LL to ignore. \\
\hline
\mbox{\texttt{ out}}  & {\em iova} & Optional pointer to receive the I\+O\+VA address for the buffer. Pass N\+U\+LL to ignore. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Non-\/zero on error. Zero on success.
\end{DoxyReturn}
Example 
\begin{DoxyCode}{0}
\DoxyCodeLine{opae\_vfio v;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{size\_t} sz;}
\DoxyCodeLine{uint8\_t *buf\_2m\_virt = NULL;}
\DoxyCodeLine{uint8\_t *buf\_1g\_virt = NULL;}
\DoxyCodeLine{uint64\_t buf\_2m\_iova = 0;}
\DoxyCodeLine{uint64\_t buf\_1g\_iova = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (opae\_vfio\_open(\&v, \textcolor{stringliteral}{"0000:00:00.0"})) \{}
\DoxyCodeLine{  \textcolor{comment}{// handle error}}
\DoxyCodeLine{\} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{  sz = 2 * 1024 * 1024;}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (opae\_vfio\_buffer\_allocate(\&v,}
\DoxyCodeLine{                                \&sz,}
\DoxyCodeLine{                                \&buf\_2m\_virt,}
\DoxyCodeLine{                                \&buf\_2m\_iova)) \{}
\DoxyCodeLine{    \textcolor{comment}{// handle allocation error}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  sz = 1024 * 1024 * 1024;}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (opae\_vfio\_buffer\_allocate(\&v,}
\DoxyCodeLine{                                \&sz,}
\DoxyCodeLine{                                \&buf\_1g\_virt,}
\DoxyCodeLine{                                \&buf\_1g\_iova)) \{}
\DoxyCodeLine{    \textcolor{comment}{// handle allocation error}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\end{DoxyCode}
 \mbox{\label{vfio_8h_ae2a60d829698d793ab9a4ad351d2596d}} 
\index{vfio.h@{vfio.h}!opae\_vfio\_buffer\_free@{opae\_vfio\_buffer\_free}}
\index{opae\_vfio\_buffer\_free@{opae\_vfio\_buffer\_free}!vfio.h@{vfio.h}}
\doxysubsubsection{\texorpdfstring{opae\_vfio\_buffer\_free()}{opae\_vfio\_buffer\_free()}}
{\footnotesize\ttfamily int opae\+\_\+vfio\+\_\+buffer\+\_\+free (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$}]{v,  }\item[{uint8\+\_\+t $\ast$}]{buf }\end{DoxyParamCaption})}

Unmap and free a system buffer

The buffer corresponding to buf must have been created by a previous call to opae\+\_\+vfio\+\_\+buffer\+\_\+allocate.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em v} & The open O\+P\+AE V\+F\+IO device. \\
\hline
\mbox{\texttt{ in}}  & {\em buf} & The virtual address corresponding to the buffer to be freed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Non-\/zero on error. Zero on success.
\end{DoxyReturn}
Example 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{size\_t} sz;}
\DoxyCodeLine{uint8\_t *buf\_2m\_virt = NULL;}
\DoxyCodeLine{uint64\_t buf\_2m\_iova = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{sz = 2 * 1024 * 1024;}
\DoxyCodeLine{\textcolor{keywordflow}{if} (opae\_vfio\_buffer\_allocate(\&v,}
\DoxyCodeLine{                              \&sz,}
\DoxyCodeLine{                              \&buf\_2m\_virt,}
\DoxyCodeLine{                              \&buf\_2m\_iova)) \{}
\DoxyCodeLine{  \textcolor{comment}{// handle allocation error}}
\DoxyCodeLine{\} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{  \textcolor{comment}{// use the buffer}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (opae\_vfio\_buffer\_free(\&v, buf\_2m\_virt)) \{}
\DoxyCodeLine{    \textcolor{comment}{// handle free error}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\end{DoxyCode}
 \mbox{\label{vfio_8h_a70fd22e64704c8f0090adb810d51fa83}} 
\index{vfio.h@{vfio.h}!opae\_vfio\_close@{opae\_vfio\_close}}
\index{opae\_vfio\_close@{opae\_vfio\_close}!vfio.h@{vfio.h}}
\doxysubsubsection{\texorpdfstring{opae\_vfio\_close()}{opae\_vfio\_close()}}
{\footnotesize\ttfamily void opae\+\_\+vfio\+\_\+close (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{vfio_8h_structopae__vfio}{opae\+\_\+vfio}} $\ast$}]{v }\end{DoxyParamCaption})}

Release and close a V\+F\+IO device

The given device pointer must have been previously initialized by opae\+\_\+vfio\+\_\+open. Releases all data structures, including any D\+MA buffer allocations that have not be explicitly freed by opae\+\_\+vfio\+\_\+buffer\+\_\+free.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em v} & Storage for the device info. May be stack-\/resident.\\
\hline
\end{DoxyParams}
Example 
\begin{DoxyCode}{0}
\DoxyCodeLine{opae\_vfio v;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (opae\_vfio\_open(\&v, \textcolor{stringliteral}{"0000:00:00.0"})) \{}
\DoxyCodeLine{  \textcolor{comment}{// handle error}}
\DoxyCodeLine{\} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{  \textcolor{comment}{// interact with the device}}
\DoxyCodeLine{  ...}
\DoxyCodeLine{  \textcolor{comment}{// free the device}}
\DoxyCodeLine{  opae\_vfio\_close(\&v);}
\DoxyCodeLine{\}}
\end{DoxyCode}


Example 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ sudo opaevfio -\/r 0000:00:00.0}
\end{DoxyCode}
 